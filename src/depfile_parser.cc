/* Generated by re2c 0.13.5 */
// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "depfile_parser.h"

#ifdef __MVS__
constexpr char EBCDIC2ASCII[] = {
0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,16,17,18,19,157,10,8,135,24,25,146,143,28,29,30,31,128,129,130,131,132,133,23,27,136,137,138,139,140,5,6,7,144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,32,160,226,228,224,225,227,229,231,241,162,46,60,40,43,124,38,233,234,235,232,237,238,239,236,223,33,36,42,41,59,94,45,47,194,196,192,193,195,197,199,209,166,44,37,95,62,63,248,201,202,203,200,205,206,207,204,96,58,35,64,39,61,34,216,97,98,99,100,101,102,103,104,105,171,187,240,253,254,177,176,106,107,108,109,110,111,112,113,114,170,186,230,184,198,164,181,126,115,116,117,118,119,120,121,122,161,191,208,91,222,174,172,163,165,183,169,167,182,188,189,190,221,168,175,93,180,215,123,65,66,67,68,69,70,71,72,73,173,244,246,242,243,245,125,74,75,76,77,78,79,80,81,82,185,251,252,249,250,255,92,247,83,84,85,86,87,88,89,90,178,212,214,210,211,213,48,49,50,51,52,53,54,55,56,57,179,219,220,217,218
};
# define TO_ASCII(x) EBCDIC2ASCII[(int)(x)]
# include <unistd.h>
#else
# define TO_ASCII(x) x
#endif

// A note on backslashes in Makefiles, from reading the docs:
// Backslash-newline is the line continuation character.
// Backslash-# escapes a # (otherwise meaningful as a comment start).
// Backslash-% escapes a % (otherwise meaningful as a special).
// Finally, quoting the GNU manual, "Backslashes that are not in danger
// of quoting ‘%’ characters go unmolested."
// How do you end a line with a backslash?  The netbsd Make docs suggest
// reading the result of a shell command echoing a backslash!
//
// Rather than implement all of above, we do a simpler thing here:
// Backslashes escape a set of characters (see "escapes" defined below),
// otherwise they are passed through verbatim.
// If anyone actually has depfiles that rely on the more complicated
// behavior we can adjust this.
bool DepfileParser::Parse(string* content, string* err) {
  // in: current parser input point.
  // end: end of input.
  // parsing_targets: whether we are parsing targets or dependencies.
  vector<char> asciicontent;
  std::transform(content->begin(), content->end(), back_inserter(asciicontent), [] (char c) -> char {
    __e2a_l(&c, 1);
    return c;
  });
  char* in = &(asciicontent)[0];
  char* end = in + asciicontent.size();
  bool parsing_targets = true;
  while (in < end) {
    // out: current output point (typically same as in, but can fall behind
    // as we de-escape backslashes).
    char* out = in;
    // filename: start of the current parsed filename.
    char* filename = out;
    for (;;) {
      // start: beginning of the current parsed span.
      const char* start = in;
      
    {
      unsigned char yych;
      static const unsigned char yybm[] = {
          0,   0,   0,   0,   0,   0,   0,   0, 
          0,   0,   0,   0,   0,   0,   0,   0, 
          0,   0,   0,   0,   0,   0,   0,   0, 
          0,   0,   0,   0,   0,   0,   0,   0, 
          0, 128,   0,   0,   0,   0,   0,   0, 
        128, 128,   0, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128,   0,   0, 128,   0,   0, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128,   0,   0,   0,   0, 128, 
          0, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128,   0, 128, 128,   0, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
        128, 128, 128, 128, 128, 128, 128, 128, 
      };

      yych = *in;
      if (yych <= TO_ASCII('=')) {
        if (yych <= TO_ASCII('$')) {
          if (yych <= TO_ASCII(' ')) {
            if (yych <= 0x00) goto yy7;
            goto yy9;
          } else {
            if (yych <= TO_ASCII('!')) goto yy5;
            if (yych <= TO_ASCII('#')) goto yy9;
            goto yy4;
          }
        } else {
          if (yych <= TO_ASCII('*')) {
            if (yych <= TO_ASCII('\'')) goto yy9;
            if (yych <= TO_ASCII(')')) goto yy5;
            goto yy9;
          } else {
            if (yych <= TO_ASCII(':')) goto yy5;
            if (yych <= TO_ASCII('<')) goto yy9;
            goto yy5;
          }
        }
      } else {
        if (yych <= TO_ASCII('_')) {
          if (yych <= TO_ASCII('[')) {
            if (yych <= TO_ASCII('?')) goto yy9;
            if (yych <= TO_ASCII('Z')) goto yy5;
            goto yy9;
          } else {
            if (yych <= TO_ASCII('\\')) goto yy2;
            if (yych <= TO_ASCII('^')) goto yy9;
            goto yy5;
          }
        } else {
          if (yych <= TO_ASCII('|')) {
            if (yych <= TO_ASCII('`')) goto yy9;
            if (yych <= TO_ASCII('{')) goto yy5;
            goto yy9;
          } else {
            if (yych == 0x7F) goto yy9;
            goto yy5;
          }
        }
      }
yy2:
      ++in;
      if ((yych = *in) <= TO_ASCII('"')) {
        if (yych <= TO_ASCII('\f')) {
          if (yych <= 0x00) goto yy3;
          if (yych != TO_ASCII('\n')) goto yy14;
        } else {
          if (yych <= TO_ASCII('\r')) goto yy3;
          if (yych == TO_ASCII(' ')) goto yy16;
          goto yy14;
        }
      } else {
        if (yych <= TO_ASCII('Z')) {
          if (yych <= TO_ASCII('#')) goto yy16;
          if (yych == TO_ASCII('*')) goto yy16;
          goto yy14;
        } else {
          if (yych <= TO_ASCII('\\')) goto yy16;
          if (yych == TO_ASCII('|')) goto yy16;
          goto yy14;
        }
      }
yy3:
      {
        // For any other character (e.g. whitespace), swallow it here,
        // allowing the outer logic to loop around again.
        break;
      }
yy4:
      yych = *++in;
      if (yych == TO_ASCII('$')) goto yy12;
      goto yy3;
yy5:
      ++in;
      yych = *in;
      goto yy11;
yy6:
      {
        // Got a span of plain text.
        int len = (int)(in - start);
        // Need to shift it over if we're overwriting backslashes.
        if (out < start)
          memmove(out, start, len);
        out += len;
        continue;
      }
yy7:
      ++in;
      {
        break;
      }
yy9:
      yych = *++in;
      goto yy3;
yy10:
      ++in;
      yych = *in;
yy11:
      if (yybm[0+yych] & 128) {
        goto yy10;
      }
      goto yy6;
yy12:
      ++in;
      {
        // De-escape dollar character.
        *out++ = TO_ASCII('$');
        continue;
      }
yy14:
      ++in;
      {
        // Let backslash before other characters through verbatim.
        *out++ = TO_ASCII('\\');
        *out++ = yych;
        continue;
      }
yy16:
      ++in;
      {
        // De-escape backslashed character.
        *out++ = yych;
        continue;
      }
    }

    }

    int len = (int)(out - filename);
    const bool is_target = parsing_targets;
    if (len > 0 && filename[len - 1] == TO_ASCII(':')) {
      len--;  // Strip off trailing colon, if any.
      parsing_targets = false;
    }

    if (len == 0)
      continue;

    if (!is_target) {
      ins_.push_back(StringPiece(filename, len));
    } else if (!out_.str_) {
      out_ = StringPiece(filename, len);
    } else if (out_ != StringPiece(filename, len)) {
      *err = "depfile has multiple output paths";
      return false;
    }
  }
  if (parsing_targets) {
    *err = "expected ':' in depfile";
    return false;
  }
  return true;
}
